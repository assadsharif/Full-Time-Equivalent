"""
CEO Briefing Commands

Commands for generating and viewing weekly CEO briefing reports.
Aggregates completed tasks and creates executive summaries.
"""

import shutil
import subprocess
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import Dict, List, Optional

import click
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn

from cli.checkpoint import get_checkpoint_manager
from cli.config import get_config
from cli.errors import BriefingError, BriefingNotFoundError, PDFGenerationError
from cli.utils import (
    display_error,
    display_info,
    display_success,
    display_warning,
    resolve_vault_path,
    validate_vault_or_error,
)

console = Console()


# Briefing template
BRIEFING_TEMPLATE = """# Weekly CEO Briefing
**Generated**: {date}
**Period**: {start_date} to {end_date}

---

## Executive Summary

{summary}

---

## Tasks Completed ({count})

{tasks}

---

## Key Metrics

- **Total Tasks Completed**: {count}
- **High Priority**: {high_priority}
- **Medium Priority**: {medium_priority}
- **Low Priority**: {low_priority}

---

## Next Week Focus

{next_week}

---

*Generated by Digital FTE AI Assistant*
"""


def calculate_date_range(days: int = 7) -> tuple:
    """
    Calculate date range for briefing.

    Args:
        days: Number of days to go back (default: 7)

    Returns:
        Tuple of (start_date, end_date) as datetime objects
    """
    end_date = datetime.now(timezone.utc)
    start_date = end_date - timedelta(days=days)
    return start_date, end_date


def scan_done_folder(
    vault_path: Path, start_date: datetime, end_date: datetime
) -> List[Dict]:
    """
    Scan /Done folder for completed tasks in date range.

    Args:
        vault_path: Path to vault
        start_date: Start of date range
        end_date: End of date range

    Returns:
        List of task dictionaries with metadata
    """
    done_dir = vault_path / "Done"

    if not done_dir.exists():
        return []

    completed_tasks = []

    # Scan for .md files
    for task_file in done_dir.glob("*.md"):
        try:
            # Parse task file
            content = task_file.read_text()

            # Extract basic info
            lines = content.split("\n")
            title = lines[0].strip("# ") if lines else task_file.stem

            # Get modification time as proxy for completion time
            # In production, would parse YAML frontmatter for completion_date
            mtime = datetime.fromtimestamp(task_file.stat().st_mtime, tz=timezone.utc)

            # Check if in date range
            if start_date <= mtime <= end_date:
                # Extract priority (if present in content)
                priority = "medium"
                content_lower = content.lower()
                if "priority: high" in content_lower or "[high]" in content_lower:
                    priority = "high"
                elif "priority: low" in content_lower or "[low]" in content_lower:
                    priority = "low"

                completed_tasks.append(
                    {
                        "file": task_file,
                        "title": title,
                        "completed_at": mtime,
                        "priority": priority,
                        "content": content,
                    }
                )

        except Exception:
            # Skip files that can't be parsed
            continue

    # Sort by completion time (newest first)
    completed_tasks.sort(key=lambda x: x["completed_at"], reverse=True)

    return completed_tasks


def generate_briefing_content(
    tasks: List[Dict], start_date: datetime, end_date: datetime
) -> str:
    """
    Generate briefing content from tasks.

    Args:
        tasks: List of task dictionaries
        start_date: Start of date range
        end_date: End of date range

    Returns:
        Formatted briefing content
    """
    # Generate summary
    if not tasks:
        summary = "No tasks were completed during this period."
    elif len(tasks) == 1:
        summary = "One task was completed during this period."
    else:
        summary = f"{len(tasks)} tasks were completed during this period, demonstrating strong productivity."

    # Format tasks list
    if not tasks:
        tasks_list = "*No tasks completed*"
    else:
        tasks_lines = []
        for task in tasks:
            priority_emoji = {"high": "ðŸ”´", "medium": "ðŸŸ¡", "low": "ðŸŸ¢"}.get(
                task["priority"], "âšª"
            )

            completed_date = task["completed_at"].strftime("%Y-%m-%d")
            tasks_lines.append(
                f"- {priority_emoji} **{task['title']}** ({completed_date})"
            )

        tasks_list = "\n".join(tasks_lines)

    # Count priorities
    high_priority = sum(1 for t in tasks if t["priority"] == "high")
    medium_priority = sum(1 for t in tasks if t["priority"] == "medium")
    low_priority = sum(1 for t in tasks if t["priority"] == "low")

    # Next week focus
    next_week = "Continue focusing on high-priority tasks and addressing any blockers."

    # Format template
    briefing_content = BRIEFING_TEMPLATE.format(
        date=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC"),
        start_date=start_date.strftime("%Y-%m-%d"),
        end_date=end_date.strftime("%Y-%m-%d"),
        summary=summary,
        tasks=tasks_list,
        count=len(tasks),
        high_priority=high_priority,
        medium_priority=medium_priority,
        low_priority=low_priority,
        next_week=next_week,
    )

    return briefing_content


def save_briefing(vault_path: Path, content: str, date: datetime) -> Path:
    """
    Save briefing to /Briefings folder.

    Args:
        vault_path: Path to vault
        content: Briefing content
        date: Date for filename

    Returns:
        Path to saved briefing file
    """
    briefings_dir = vault_path / "Briefings"
    briefings_dir.mkdir(exist_ok=True)

    # Generate filename
    filename = f"briefing_{date.strftime('%Y-%m-%d')}.md"
    briefing_path = briefings_dir / filename

    # Save file
    briefing_path.write_text(content)

    return briefing_path


def check_wkhtmltopdf_installed() -> bool:
    """
    Check if wkhtmltopdf is installed.

    Returns:
        True if wkhtmltopdf is available
    """
    return shutil.which("wkhtmltopdf") is not None


def generate_pdf(markdown_path: Path, pdf_path: Path) -> None:
    """
    Generate PDF from markdown file using wkhtmltopdf.

    Args:
        markdown_path: Path to markdown file
        pdf_path: Path to output PDF

    Raises:
        PDFGenerationError: If PDF generation fails
    """
    if not check_wkhtmltopdf_installed():
        raise PDFGenerationError(
            "wkhtmltopdf is not installed. Install with: apt-get install wkhtmltopdf"
        )

    try:
        # Convert markdown to HTML first (simple conversion)
        # In production, would use a proper markdown library like markdown2
        html_content = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        h1 {{ color: #333; border-bottom: 2px solid #333; }}
        h2 {{ color: #666; margin-top: 30px; }}
        code {{ background: #f4f4f4; padding: 2px 5px; }}
    </style>
</head>
<body>
    <pre>{markdown_path.read_text()}</pre>
</body>
</html>
"""

        # Create temporary HTML file
        html_path = markdown_path.with_suffix(".html")
        html_path.write_text(html_content)

        # Run wkhtmltopdf
        result = subprocess.run(
            ["wkhtmltopdf", str(html_path), str(pdf_path)],
            capture_output=True,
            text=True,
            timeout=30,
        )

        # Clean up HTML file
        html_path.unlink()

        if result.returncode != 0:
            raise PDFGenerationError(f"wkhtmltopdf failed: {result.stderr}")

    except subprocess.TimeoutExpired:
        raise PDFGenerationError("PDF generation timed out")
    except Exception as e:
        raise PDFGenerationError(f"Failed to generate PDF: {e}")


def find_latest_briefing(vault_path: Path) -> Optional[Path]:
    """
    Find the most recent briefing in /Briefings folder.

    Args:
        vault_path: Path to vault

    Returns:
        Path to latest briefing, or None if not found
    """
    briefings_dir = vault_path / "Briefings"

    if not briefings_dir.exists():
        return None

    # Get all briefing files
    briefings = list(briefings_dir.glob("briefing_*.md"))

    if not briefings:
        return None

    # Sort by modification time (newest first)
    briefings.sort(key=lambda x: x.stat().st_mtime, reverse=True)

    return briefings[0]


def detect_markdown_viewer() -> Optional[str]:
    """
    Detect available markdown viewer.

    Returns:
        Command to open markdown files, or None
    """
    # Check for common markdown viewers
    viewers = [
        "typora",
        "obsidian",
        "marktext",
        "ghostwriter",
    ]

    for viewer in viewers:
        if shutil.which(viewer):
            return viewer

    # Fallback to cat
    if shutil.which("cat"):
        return "cat"

    return None


def open_briefing(briefing_path: Path) -> None:
    """
    Open briefing in default viewer.

    Args:
        briefing_path: Path to briefing file

    Raises:
        BriefingError: If no viewer is available
    """
    viewer = detect_markdown_viewer()

    if not viewer:
        raise BriefingError(
            "No markdown viewer found. Install typora, obsidian, or use cat."
        )

    try:
        if viewer == "cat":
            # Display in console
            content = briefing_path.read_text()
            console.print(content)
        else:
            # Open in external viewer
            subprocess.run([viewer, str(briefing_path)], check=False)

    except Exception as e:
        raise BriefingError(f"Failed to open briefing: {e}")


# CLI Commands


@click.group(name="briefing")
def briefing_group():
    """CEO briefing commands"""
    pass


@briefing_group.command(name="generate")
@click.option(
    "--vault-path",
    type=click.Path(path_type=Path),
    help="Path to vault (overrides config)",
)
@click.option(
    "--days",
    default=7,
    type=int,
    help="Number of days to include (default: 7)",
)
@click.option(
    "--pdf",
    is_flag=True,
    help="Generate PDF in addition to Markdown",
)
@click.option(
    "--email",
    type=str,
    default=None,
    help="Email the briefing to this address after generation",
)
@click.pass_context
def briefing_generate_command(
    ctx: click.Context,
    vault_path: Optional[Path],
    days: int,
    pdf: bool,
    email: Optional[str],
):
    """
    Generate CEO briefing report.

    Aggregates completed tasks from the past week and creates
    an executive summary report in the /Briefings folder.

    Examples:
        fte briefing generate
        fte briefing generate --days 14
        fte briefing generate --pdf
        fte briefing generate --pdf --email ceo@company.com
    """
    try:
        # Resolve vault path
        if vault_path is None:
            vault_path = resolve_vault_path()

        # Validate vault
        validate_vault_or_error(vault_path)

        # Progress bar
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console,
        ) as progress:
            # Calculate date range
            task_id = progress.add_task("Calculating date range...", total=None)
            start_date, end_date = calculate_date_range(days)

            # Scan done folder
            progress.update(task_id, description="Scanning completed tasks...")
            tasks = scan_done_folder(vault_path, start_date, end_date)

            if not tasks:
                progress.stop()
                display_info("\nNo tasks completed in the specified period.")
                display_info("Briefing will be generated with empty task list.")

            # Generate briefing content
            progress.update(task_id, description="Generating briefing content...")
            content = generate_briefing_content(tasks, start_date, end_date)

            # Save briefing
            progress.update(task_id, description="Saving briefing...")
            briefing_path = save_briefing(vault_path, content, end_date)

            # Generate PDF if requested
            if pdf:
                if check_wkhtmltopdf_installed():
                    progress.update(task_id, description="Generating PDF...")
                    pdf_path = briefing_path.with_suffix(".pdf")
                    try:
                        generate_pdf(briefing_path, pdf_path)
                        progress.stop()
                        display_success(f"PDF generated: {pdf_path}")
                    except PDFGenerationError as e:
                        progress.stop()
                        display_warning(f"PDF generation failed: {e}")
                else:
                    progress.stop()
                    display_warning(
                        "wkhtmltopdf not installed. Skipping PDF generation."
                    )
                    display_info("Install with: apt-get install wkhtmltopdf")

        # Email delivery (optional)
        if email:
            from briefing.email_delivery import EmailDeliveryService

            email_svc = EmailDeliveryService()
            highlights = [
                f"{len(tasks)} tasks completed",
                f"Period: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}",
            ]
            attachment = briefing_path
            if pdf:
                pdf_candidate = briefing_path.with_suffix(".pdf")
                if pdf_candidate.exists():
                    attachment = pdf_candidate
            if email_svc.send_briefing_email(
                email, attachment, start_date, end_date, highlights
            ):
                display_success(f"Briefing emailed to: {email}")
            else:
                display_warning("Email delivery failed or SMTP not configured")

        # Update checkpoint
        checkpoint_manager = get_checkpoint_manager()
        checkpoint_manager.update_briefing(generated=True)

        display_success(f"\nâœ“ Briefing generated successfully")
        display_info(f"Location: {briefing_path}")
        display_info(
            f"Period: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}"
        )
        display_info(f"Tasks included: {len(tasks)}")
        display_info(f"\nView briefing: fte briefing view")

    except (BriefingError, PDFGenerationError) as e:
        display_error(e, verbose=ctx.obj.get("verbose", False) if ctx.obj else False)
        ctx.exit(1)
    except Exception as e:
        display_error(e, verbose=ctx.obj.get("verbose", False) if ctx.obj else False)
        ctx.exit(1)


@briefing_group.command(name="view")
@click.option(
    "--vault-path",
    type=click.Path(path_type=Path),
    help="Path to vault (overrides config)",
)
@click.pass_context
def briefing_view_command(ctx: click.Context, vault_path: Optional[Path]):
    """
    View most recent briefing.

    Opens the latest briefing report in the default markdown viewer
    or displays it in the console if no viewer is available.

    Examples:
        fte briefing view
        fte briefing view --vault-path ~/AI_Employee_Vault
    """
    try:
        # Resolve vault path
        if vault_path is None:
            vault_path = resolve_vault_path()

        # Validate vault
        validate_vault_or_error(vault_path)

        display_info("Finding latest briefing...")

        # Find latest briefing
        briefing_path = find_latest_briefing(vault_path)

        if not briefing_path:
            raise BriefingNotFoundError()

        display_info(f"Opening: {briefing_path.name}")

        # Open briefing
        open_briefing(briefing_path)

        if detect_markdown_viewer() != "cat":
            display_success("\nâœ“ Briefing opened in viewer")

    except (BriefingNotFoundError, BriefingError) as e:
        display_error(e, verbose=ctx.obj.get("verbose", False) if ctx.obj else False)
        ctx.exit(1)
    except Exception as e:
        display_error(e, verbose=ctx.obj.get("verbose", False) if ctx.obj else False)
        ctx.exit(1)
