"""
Approval Checker — HITL gate before dangerous actions.

Scans a task's markdown body for approval-required keywords.  If a match
is found the task is routed to /Approvals and blocked until a human
approves or rejects it via ``fte vault approve``.

Zero-bypass guarantee: if keyword match → approval required, no
exceptions.  The orchestrator never executes a flagged task without an
explicit approval file in /Approvals with status "approved".
"""

import re
from pathlib import Path
from typing import Optional

from src.orchestrator.models import OrchestratorConfig


class ApprovalChecker:
    """Determines whether a task needs HITL approval and checks status."""

    def __init__(self, config: Optional[OrchestratorConfig] = None):
        self.config = config or OrchestratorConfig()
        self._approvals_path = self.config.vault_path / "Approvals"
        # Pre-compile keyword patterns
        self._patterns = [
            re.compile(r"\b" + re.escape(kw) + r"\b", re.IGNORECASE)
            for kw in self.config.approval_keywords
        ]

    # ------------------------------------------------------------------
    # Public
    # ------------------------------------------------------------------

    def requires_approval(self, task_path: Path) -> bool:
        """Return True if task body contains any approval-required keyword."""
        text = task_path.read_text(encoding="utf-8")
        return any(p.search(text) for p in self._patterns)

    def matched_keywords(self, task_path: Path) -> list[str]:
        """Return list of keywords that matched in the task body."""
        text = task_path.read_text(encoding="utf-8")
        return [
            kw for kw, p in zip(self.config.approval_keywords, self._patterns)
            if p.search(text)
        ]

    def is_approved(self, task_path: Path) -> bool:
        """
        Check whether an approval file exists for this task and is approved.

        Looks in /Approvals for a file whose name contains the task stem
        and whose body contains ``Status**: ✅ Approved`` or
        ``approval_status: approved``.
        """
        if not self._approvals_path.exists():
            return False

        stem = task_path.stem.lower()
        for approval_file in self._approvals_path.glob("*.md"):
            if stem in approval_file.name.lower() or approval_file.name.lower() in stem:
                body = approval_file.read_text(encoding="utf-8").lower()
                if "approved" in body and "pending" not in body:
                    return True
        return False

    def create_approval_request(self, task_path: Path, keywords: list[str]) -> Path:
        """
        Write an approval-request .md file into /Approvals.

        Returns the path of the created file.
        """
        self._approvals_path.mkdir(parents=True, exist_ok=True)

        from datetime import datetime, timezone  # noqa: E402

        now = datetime.now(timezone.utc).isoformat()
        stem = task_path.stem
        approval_path = self._approvals_path / f"approval-{stem}.md"

        content = (
            f"# Approval Request: {task_path.name}\n\n"
            f"**Request ID**: APR-{stem}\n"
            f"**Created**: {now}\n"
            f"**Priority**: High\n"
            f"**Status**: ⏳ Pending Review\n\n"
            f"## Triggered By\n\n"
            f"Keywords detected: {', '.join(keywords)}\n\n"
            f"## Source Task\n\n"
            f"`{task_path.name}`\n\n"
            f"## Options\n\n"
            f"1. **Approve**: `fte vault approve APR-{stem}`\n"
            f"2. **Reject**: `fte vault reject APR-{stem}`\n\n"
            f"---\n"
            f"*Auto-generated by Orchestrator Approval Checker*\n"
        )
        approval_path.write_text(content)
        return approval_path
