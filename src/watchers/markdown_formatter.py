"""
Markdown Formatter for watcher scripts.

Generates Markdown files with YAML frontmatter from watcher events.
"""

from datetime import datetime, timezone
from pathlib import Path
from typing import Any

import yaml

# Try to import the logging module, fall back to standard logging
try:
    from src.logging import get_logger
except ImportError:
    import logging

    def get_logger(name: str):
        return logging.getLogger(name)


from .models import EmailMessage, FileEvent, WhatsAppMessage, WatcherEvent

logger = get_logger(__name__)


class MarkdownFormatter:
    """
    Formats watcher events as Markdown files with YAML frontmatter.

    Example output:
        ---
        id: gmail_user_example_com_2026-01-28T10-30-00
        source: gmail
        sender: user@example.com
        subject: "Important Task"
        received: 2026-01-28T10:30:00Z
        priority: high
        pii_redacted: true
        ---

        # Task from Gmail: Important Task

        **From**: user@example.com
        **Subject**: Important Task

        ## Content

        Email body here...

        ---

        _Auto-generated by Gmail Watcher_
    """

    def __init__(self, default_priority: str = "medium"):
        """
        Initialize MarkdownFormatter.

        Args:
            default_priority: Default priority for events without explicit priority
        """
        self.default_priority = default_priority

    def format_email(self, email: EmailMessage) -> str:
        """
        Format email message as Markdown.

        Args:
            email: EmailMessage model

        Returns:
            Markdown string with YAML frontmatter
        """
        # Generate ID if not set
        if not email.id:
            email.id = email.generate_id()

        frontmatter = {
            "id": email.id,
            "source": email.source,
            "message_id": email.message_id,
            "sender": email.sender,
            "subject": email.subject,
            "received": email.timestamp.isoformat(),
            "priority": email.priority or self.default_priority,
            "has_attachments": email.has_attachments,
            "pii_redacted": email.pii_redacted,
            "labels": email.labels,
            "status": "needs_action",
        }

        body_parts = [
            f"# Task from Gmail: {email.subject}",
            "",
            f"**From**: {email.sender}",
            f"**Received**: {email.timestamp.strftime('%Y-%m-%d %H:%M %Z')}",
            f"**Subject**: {email.subject}",
            "",
            "## Content",
            "",
            email.body,
        ]

        if email.has_attachments and email.attachments:
            body_parts.extend(
                [
                    "",
                    "## Attachments",
                    "",
                ]
            )
            for attachment in email.attachments:
                body_parts.append(f"- `{attachment}`")

        body_parts.extend(
            [
                "",
                "---",
                "",
                "_Auto-generated by Gmail Watcher_",
            ]
        )

        return self._format_document(frontmatter, "\n".join(body_parts))

    def format_file_event(self, event: FileEvent) -> str:
        """
        Format file event as Markdown.

        Args:
            event: FileEvent model

        Returns:
            Markdown string with YAML frontmatter
        """
        # Generate ID if not set
        if not event.id:
            event.id = event.generate_id()

        frontmatter = {
            "id": event.id,
            "source": event.source,
            "file_path": str(event.file_path),
            "file_name": event.file_name,
            "file_size": event.file_size,
            "file_type": event.file_type,
            "file_hash": event.file_hash,
            "detected_at": event.timestamp.isoformat(),
            "event_type": event.event_type,
            "priority": event.priority or self.default_priority,
            "pii_redacted": event.pii_redacted,
            "status": "needs_action",
        }

        # Format file size for display
        size_display = self._format_file_size(event.file_size)

        body_parts = [
            f"# New File Detected: {event.file_name}",
            "",
            f"**Location**: `{event.file_path.parent}/`",
            "",
            "## File Details",
            "",
            f"- **Type**: {event.file_type}",
            f"- **Size**: {size_display}",
            (
                f"- **SHA256**: `{event.file_hash[:16]}...`"
                if event.file_hash
                else "- **SHA256**: (not computed)"
            ),
            "",
            "## AI Employee Instructions",
            "",
            "1. Analyze file content and determine processing steps",
            "2. Extract key information or metadata",
            "3. Move to appropriate /Done subdirectory when complete",
            "",
            "---",
            "",
            "_Auto-generated by FileSystem Watcher_",
        ]

        return self._format_document(frontmatter, "\n".join(body_parts))

    def format_whatsapp(self, message: WhatsAppMessage) -> str:
        """
        Format WhatsApp message as Markdown.

        Args:
            message: WhatsAppMessage model

        Returns:
            Markdown string with YAML frontmatter
        """
        # Generate ID if not set
        if not message.id:
            message.id = message.generate_id()

        frontmatter = {
            "id": message.id,
            "source": message.source,
            "message_id": message.message_id,
            "sender_phone": message.sender_phone,
            "received": message.timestamp.isoformat(),
            "message_type": message.message_type,
            "priority": message.priority or self.default_priority,
            "has_media": message.has_media,
            "pii_redacted": message.pii_redacted,
            "status": "needs_action",
        }

        body_parts = [
            f"# WhatsApp Message from {message.sender_phone}",
            "",
            "## Message",
            "",
            message.body,
        ]

        if message.has_media and message.media_path:
            body_parts.extend(
                [
                    "",
                    "## Media",
                    "",
                    f"- `{message.media_path}`",
                ]
            )

        body_parts.extend(
            [
                "",
                "---",
                "",
                "_Auto-generated by WhatsApp Watcher_",
            ]
        )

        return self._format_document(frontmatter, "\n".join(body_parts))

    def format_generic(self, event: WatcherEvent, title: str, body: str) -> str:
        """
        Format a generic watcher event as Markdown.

        Args:
            event: WatcherEvent model
            title: Document title
            body: Document body content

        Returns:
            Markdown string with YAML frontmatter
        """
        frontmatter = {
            "id": event.id,
            "source": event.source,
            "timestamp": event.timestamp.isoformat(),
            "priority": event.priority or self.default_priority,
            "pii_redacted": event.pii_redacted,
            "status": "needs_action",
        }

        full_body = f"# {title}\n\n{body}\n\n---\n\n_Auto-generated by {event.source.title()} Watcher_"

        return self._format_document(frontmatter, full_body)

    def _format_document(self, frontmatter: dict[str, Any], body: str) -> str:
        """
        Format complete Markdown document with YAML frontmatter.

        Args:
            frontmatter: Dictionary of frontmatter fields
            body: Markdown body content

        Returns:
            Complete Markdown document
        """
        # Use safe_dump to properly escape strings
        yaml_str = yaml.safe_dump(
            frontmatter,
            default_flow_style=False,
            allow_unicode=True,
            sort_keys=False,
        )

        return f"---\n{yaml_str}---\n\n{body}\n"

    def _format_file_size(self, size_bytes: int) -> str:
        """Format file size in human-readable format."""
        for unit in ["B", "KB", "MB", "GB", "TB"]:
            if size_bytes < 1024:
                return f"{size_bytes:.1f} {unit}"
            size_bytes /= 1024
        return f"{size_bytes:.1f} PB"

    def write_to_file(self, content: str, filepath: Path) -> Path:
        """
        Write Markdown content to file atomically.

        Args:
            content: Markdown content
            filepath: Target file path

        Returns:
            Path to written file
        """
        # Ensure parent directory exists
        filepath.parent.mkdir(parents=True, exist_ok=True)

        # Write atomically using temp file
        temp_path = filepath.with_suffix(".tmp")
        try:
            temp_path.write_text(content, encoding="utf-8")
            temp_path.rename(filepath)
            logger.info(f"Markdown written to {filepath}")
            return filepath
        except Exception as e:
            # Clean up temp file on error
            if temp_path.exists():
                temp_path.unlink()
            raise
